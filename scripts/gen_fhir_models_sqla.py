"""
Generate SQLAlchemy ORM models.

Utility script for  SDX that inspects Pydantic models
(from both `fhir_models` and `custom_models`) and produces a basic
SQLAlchemy 2.x ORM layer with one table per Pydantic class.

Usage:
    python generate_orm_models.py

Output:
    Overwrites/creates `telehealthcare_ai/db/orm_models.py`
    with autogenerated Declarative mapping code.

Notes
-----
* Only scalar field types (str, int, float, bool, datetime) and simple
  collections are handled automatically. Complex nested objects will be
  serialised into JSON columns.
* Relationships (foreign keys) are not inferred; add them manually.
* Requires pydantic>=2.0, SQLAlchemy>=2.0.
"""

from __future__ import annotations

import inspect
import pkgutil
import shutil
import subprocess
import sys

from datetime import date, datetime
from pathlib import Path
from types import ModuleType
from typing import Any, Dict, Type

from pydantic import BaseModel
from sdx.schema.fhir import BaseLanguage

# Package paths to scan for Pydantic models
PACKAGE_PATHS = [
    'sdx.schema',
]

# Target file to (over)write
OUTPUT_PATH = (
    Path(__file__).resolve().parent.parent
    / 'src'
    / 'sdx'
    / 'models'
    / 'fhir.py'
)


TYPE_MAP = {
    str: 'String',
    int: 'Integer',
    float: 'Float',
    bool: 'Boolean',
    datetime: 'DateTime',
    date: 'Date',
}

# Fallback SQLAlchemy type for arbitrary / nested data
FALLBACK_TYPE = 'JSON'

IGNORED_CLASSES = [BaseLanguage, BaseModel]


def run_ruff(path: Path, *, fix: bool = True) -> None:
    """
    Format / lint the generated file with Ruff.

    Parameters
    ----------
        path: Absolute path to the file that was just written.
        fix:  If True, run Ruff with `--fix`; otherwise `check` only.

    Raises
    ------
        RuntimeError: If Ruff is not installed or returns a non-zero exit code.
    """
    ruff_exe = shutil.which('ruff')
    if ruff_exe is None:
        raise RuntimeError(
            'Ruff executable not found. '
            'Install with `pip install ruff` or add it to your PATH.'
        )

    cmd = [ruff_exe, 'format', str(path)]

    try:
        subprocess.run(cmd, check=True)
        print(f'[✓] Ruff {"fixed" if fix else "checked"} {path}')
    except subprocess.CalledProcessError as exc:
        raise RuntimeError(
            f'Ruff reported issues (exit code {exc.returncode}).'
        ) from exc


def _is_concrete_model(model_cls: Type[BaseModel]) -> bool:
    """
    Return True if `model_cls` should be mapped to a table.

    Heuristics
    ----------
    1. The class advertises itself as abstract via `__abstract__ = True`.
    2. Inner `Config` / `model_config` sets `table_abstract = True`.
    3. No own fields ➜ skip (helper alias such as BaseLanguage).
    """
    # Rule 1: explicit marker
    if getattr(model_cls, '__abstract__', False):
        return False

    # Rule 2: honour Pydantic v1 Config or v2 model_config
    cfg = getattr(model_cls, 'Config', None) or getattr(
        model_cls, 'model_config', None
    )
    if cfg and getattr(cfg, 'table_abstract', False):
        return False

    # Rule 3: helper types usually have zero model_fields
    if not model_cls.model_fields:
        return False

    return True


def python_type_to_sqla(annotation: Any) -> tuple[str, str]:
    """
    Return a pair ``(sqlalchemy_type_name, python_hint_string)``.

    * Scalars map to a concrete SA type and their own type-name hint
      (e.g. ``("String", "str")``).
    * Lists / dicts / unknown objects fall back to JSON + ``Any``.
    """
    origin = getattr(annotation, '__origin__', None)

    # Generic collections → JSON
    if origin in (list, dict):
        return FALLBACK_TYPE, 'Any'

    # Exact scalar matches
    if annotation in TYPE_MAP:
        return TYPE_MAP[annotation], annotation.__name__

    #   sqlalchemy.DateTime  ←  datetime | Arrow | pendulum types
    if annotation is datetime:
        return 'DateTime', 'datetime'

    # Anything else → JSON
    return FALLBACK_TYPE, 'Any'


def iter_pydantic_models() -> Dict[str, Type[BaseModel]]:
    """
    Yield (qualified_name, model_cls).

    Yield values for every subclass of BaseModel found in PACKAGE_PATHS.
    """
    discovered: Dict[str, Type[BaseModel]] = {}
    for module_path in PACKAGE_PATHS:
        module: ModuleType = __import__(module_path, fromlist=['*'])
        # Walk submodules in case of package
        for _loader, submod_name, _ispkg in pkgutil.walk_packages(
            module.__path__, module.__name__ + '.'
        ):
            submod = __import__(submod_name, fromlist=['*'])
            for name, obj in inspect.getmembers(submod, inspect.isclass):
                if not obj.__module__.startswith('sdx'):
                    continue
                if issubclass(obj, BaseModel) and obj not in IGNORED_CLASSES:
                    discovered[f'{submod.__name__}.{name}'] = obj
    return discovered


def generate_sqla_model(name: str, model_cls: Type[BaseModel]) -> str:
    """
    Create a SQLAlchemy declarative model class for a given Pydantic model.

    Rules
    -----
    * If the Pydantic model has **no scalar field** that can act
      as a primary key, inject a surrogate UUID ``id`` column.
    * Non-scalar or complex fields are mapped to JSON columns.
    """
    lines: list[str] = []
    table_name = name.lower()
    lines.append(f'class {name}(Base):')
    lines.append(f"    __tablename__ = '{table_name}'")
    lines.append('')

    fields = model_cls.model_fields

    has_scalar_pk_candidate = any(
        python_type_to_sqla(field.annotation)[0] != FALLBACK_TYPE
        for field in fields.values()
    )
    inject_uuid_pk = not has_scalar_pk_candidate

    if inject_uuid_pk:
        lines.append(
            '    id: Mapped[str] = mapped_column('
            'String(36), primary_key=True, '
            'default=lambda: str(uuid.uuid4())'
            ')'
        )

    for field_name, field_info in fields.items():
        # Skip if surrogate PK already added
        if inject_uuid_pk and field_name == 'id':
            continue

        sa_type, py_hint = python_type_to_sqla(field_info.annotation)

        nullable = 'True' if not field_info.is_required() else 'False'
        primary = (
            'True' if (field_name == 'id' and not inject_uuid_pk) else 'False'
        )

        col_args = [
            sa_type,
            'primary_key=True' if primary == 'True' else None,
            'nullable=True' if nullable == 'True' else None,
            'index=True' if primary == 'False' else None,
        ]
        col_args = ', '.join(arg for arg in col_args if arg)

        lines.append(
            f'    {field_name}: Mapped[{py_hint}] = mapped_column({col_args})'
        )

    lines.append('')
    return '\n'.join(lines)


def build_orm_file(models: Dict[str, Type[BaseModel]]) -> str:
    """Compose the full orm_models.py content."""
    header = """\"\"\"Autogenerated ORM models from Pydantic schemas.

DO NOT EDIT MANUALLY. Regenerate via `python generate_orm_models.py`.
\"\"\"

from __future__ import annotations

import uuid

from typing import Any, Optional, Union  # noqa

from fhir.resources.fhirtypes import (
    ReferenceType,  # noqa
    CodeableConceptType,  # noqa
)
from public import public
from sqlalchemy import (
    Boolean,  # noqa
    Date,  # noqa
    DateTime,  # noqa
    Float,  # noqa
    Integer,  # noqa
    JSON,  # noqa
    String,  # noqa
    Text,  # noqa
)
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column


@public
class Base(DeclarativeBase):
    \"\"\"Declarative base for  SDX.\"\"\"
    pass

"""
    body = []
    for model_cls in models.values():
        if not _is_concrete_model(model_cls):
            continue
        body += [
            '@public\n' + generate_sqla_model(model_cls.__name__, model_cls)
        ]

    return header + '\n\n'.join(body) + '\n'


def main() -> None:
    """Execute the main function."""
    models = iter_pydantic_models()
    orm_code = build_orm_file(models)

    OUTPUT_PATH.parent.mkdir(parents=True, exist_ok=True)
    OUTPUT_PATH.write_text(orm_code, encoding='utf-8')

    print(f'[✓] ORM models written to {OUTPUT_PATH}')

    try:
        run_ruff(OUTPUT_PATH, fix=True)
    except RuntimeError as err:
        # Fallback: continue without failing the generator
        print(f'[!] Ruff step skipped: {err}')


if __name__ == '__main__':
    sys.exit(main())
