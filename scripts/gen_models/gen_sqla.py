"""
Generate SQLAlchemy ORM models.

Utility script for  SDX that inspects Pydantic models
(from both `fhir_models` and `custom_models`) and produces a basic
SQLAlchemy 2.x ORM layer with one table per Pydantic class.

Usage:
    python generate_orm_models.py

Output:
    Overwrites/creates `telehealthcare_ai/db/orm_models.py`
    with autogenerated Declarative mapping code.

Notes
-----
* Only scalar field types (str, int, float, bool, datetime) and simple
  collections are handled automatically. Complex nested objects will be
  serialised into JSON columns.
* Relationships (foreign keys) are not inferred; add them manually.
* Requires pydantic>=2.0, SQLAlchemy>=2.0.
"""

from __future__ import annotations

import sys

from datetime import date, datetime
from pathlib import Path
from typing import Any, Dict, Type

from formatting import run_ruff
from gen_base import is_concrete_model, iter_pydantic_models
from pydantic import BaseModel

# Target file to (over)write
OUTPUT_PATH = (
    Path(__file__).resolve().parent.parent.parent
    / 'src'
    / 'sdx'
    / 'models'
    / 'sqla'
    / 'fhir.py'
)


TYPE_MAP = {
    str: 'String',
    int: 'Integer',
    float: 'Float',
    bool: 'Boolean',
    datetime: 'DateTime',
    date: 'Date',
}

# Fallback SQLAlchemy type for arbitrary / nested data
FALLBACK_TYPE = 'JSON'


def python_type_to_sqla(annotation: Any) -> tuple[str, str]:
    """
    Return a pair ``(sqlalchemy_type_name, python_hint_string)``.

    * Scalars map to a concrete SA type and their own type-name hint
      (e.g. ``("String", "str")``).
    * Lists / dicts / unknown objects fall back to JSON + ``Any``.
    """
    origin = getattr(annotation, '__origin__', None)

    # Generic collections → JSON
    if origin in (list, dict):
        return FALLBACK_TYPE, 'Any'

    # Exact scalar matches
    if annotation in TYPE_MAP:
        return TYPE_MAP[annotation], annotation.__name__

    #   sqlalchemy.DateTime  ←  datetime | Arrow | pendulum types
    if annotation is datetime:
        return 'DateTime', 'datetime'

    # Anything else → JSON
    return FALLBACK_TYPE, 'Any'


def generate_sqla_model(name: str, model_cls: Type[BaseModel]) -> str:
    """Return the SQLAlchemy declarative model as source code."""
    lines: list[str] = []
    lines.append('@public')
    lines.append(f'class {name}(Base):')
    lines.append(f'    """{name} autogenerated."""\n')
    lines.append(f"    __tablename__ = '{name.lower()}'")
    lines.append('')

    fields = model_cls.model_fields

    id_field = fields.get('id')
    inject_uuid_pk = (
        id_field is None
        or python_type_to_sqla(id_field.annotation)[0] == FALLBACK_TYPE
    )

    if inject_uuid_pk:
        lines.append(
            '    id: Mapped[str] = mapped_column('
            'String(36), primary_key=True, '
            'default=lambda: str(uuid.uuid4()))'
        )

    for field_name, field_info in fields.items():
        # skip original id when surrogate already added
        if inject_uuid_pk and field_name == 'id':
            continue

        sa_type, py_hint = python_type_to_sqla(field_info.annotation)
        nullable = not field_info.is_required()
        is_pk = field_name == 'id' and not inject_uuid_pk

        col_args = [
            sa_type,
            'primary_key=True' if is_pk else None,
            'nullable=True' if nullable else None,
            'index=True' if not is_pk else None,
        ]
        col_args = ', '.join(arg for arg in col_args if arg)

        default_token = 'None' if nullable else '...'

        lines.append(
            f'    {field_name}: Mapped[{py_hint}] = mapped_column('
            f'{col_args}, default={default_token})'
            if field_name != 'id'
            else (
                f'    {field_name}: Mapped[{py_hint}] = '
                f'mapped_column({col_args})'
            )
        )

    lines.append('')
    return '\n'.join(lines)


def build_orm_file(models: Dict[str, Type[BaseModel]]) -> str:
    """Compose the full orm_models.py content."""
    header = """\"\"\"Autogenerated ORM models from Pydantic schemas.

DO NOT EDIT MANUALLY. Regenerate via `python generate_orm_models.py`.
\"\"\"

from __future__ import annotations

import datetime
import uuid

from typing import Any, Literal, Optional, Union  # noqa

from fhir.resources.fhirtypes import (
    ReferenceType,  # noqa
    CodeableConceptType,  # noqa
)
from public import public
from sqlalchemy import (
    Boolean,
    Date,
    DateTime,
    Float,
    Integer,
    JSON,
    String,
    Text,
)
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column


@public
class Base(DeclarativeBase):
    \"\"\"Declarative base for  SDX.\"\"\"
    pass

"""
    body = []
    for model_cls in models.values():
        if not is_concrete_model(model_cls):
            continue
        body += [
            '@public\n' + generate_sqla_model(model_cls.__name__, model_cls)
        ]

    return header + '\n\n'.join(body) + '\n'


def main() -> None:
    """Execute the main function."""
    models = iter_pydantic_models()
    orm_code = build_orm_file(models)

    OUTPUT_PATH.parent.mkdir(parents=True, exist_ok=True)
    OUTPUT_PATH.write_text(orm_code, encoding='utf-8')

    print(f'[✓] ORM models written to {OUTPUT_PATH}')

    try:
        run_ruff(OUTPUT_PATH, fix=True)
    except RuntimeError as err:
        # Fallback: continue without failing the generator
        print(f'[!] Ruff step skipped: {err}')


if __name__ == '__main__':
    sys.exit(main())
