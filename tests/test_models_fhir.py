# tests/test_orm_models.py
"""
Smoke-tests for the autogenerated SQLAlchemy models in
`telehealthcare_ai.db.orm_models`.

Goals
-----
1. Tables create successfully in an in-memory SQLite database.
2. Every mapped class:
   • Has at least one primary-key column.
   • Can be instantiated with dummy values for non-nullable columns.
   • Persists and can be queried back without raising.

These tests do **not** assert domain logic; they simply guarantee that
basic CRUD operations work and that the autogenerated code is syntactically
and structurally valid.
"""

from __future__ import annotations

import inspect

from datetime import date, datetime
from typing import Any, Dict

import pytest
import sdx.models.fhir as orm_models

from sdx.models.fhir import Base
from sqlalchemy import (
    JSON,
    Boolean,
    Date,
    DateTime,
    Float,
    Integer,
    String,
    create_engine,
)
from sqlalchemy import inspect as sa_inspect
from sqlalchemy.orm import Session, sessionmaker


@pytest.fixture(scope='session')
def engine():
    """In-memory SQLite engine for fast, isolated tests."""
    return create_engine('sqlite:///:memory:', future=True, echo=False)


@pytest.fixture(scope='session')
def tables(engine):
    """Create tables once per test session and tear them down afterwards."""
    Base.metadata.create_all(engine)
    yield
    Base.metadata.drop_all(engine)


@pytest.fixture
def db_session(engine, tables):
    """Provide a transactional SQLAlchemy session per test."""
    SessionLocal = sessionmaker(bind=engine, future=True)
    with SessionLocal() as session:
        yield session
        session.rollback()  # isolate each test


_SQLA_TYPE_MAP = {
    String: 'sample',
    Integer: 1,
    Float: 1.0,
    Boolean: True,
    DateTime: datetime.utcnow(),
    Date: date.today(),
    JSON: {},  # Fallback for complex / nested structures
}


def _sample_for_column(column) -> Any:
    """
    Return a dummy value compatible with the SQLAlchemy Column's type.

    Falls back to ``{}`` for any unrecognised or JSON-like column.
    """
    for sqla_type, value in _SQLA_TYPE_MAP.items():
        if isinstance(column.type, sqla_type):
            # If String has length constraint, ensure sample shorter
            if isinstance(column.type, String) and column.type.length:
                return 'x' * min(8, column.type.length)
            return value
    return {}  # default


def _iter_model_classes() -> list[type]:
    """Yield all mapped subclasses declared in orm_models."""
    for _name, obj in inspect.getmembers(orm_models, inspect.isclass):
        if (
            issubclass(obj, Base)
            and obj is not Base
            and hasattr(obj, '__tablename__')
        ):
            yield obj


def test_tables_created(engine, tables):
    """Metadata reflection should list at least one table."""
    insp = sa_inspect(engine)
    assert insp.get_table_names(), (
        'No tables were created by metadata.create_all()'
    )


@pytest.mark.parametrize('model_cls', _iter_model_classes())
def test_model_basic_crud(model_cls, db_session: Session):
    """
    Instantiate each model with sample data.

    Instantiate each model with sample data for required fields,
    persist, and query it back.
    """
    # Build kwargs for non-nullable columns (or primary key)
    init_kwargs: Dict[str, Any] = {}
    for column in model_cls.__table__.columns:
        if column.primary_key or not column.nullable:
            init_kwargs[column.name] = _sample_for_column(column)

    # Primary key must be supplied; otherwise SQLAlchemy will autogenerate
    obj = model_cls(**init_kwargs)
    db_session.add(obj)
    db_session.commit()

    pk_name = model_cls.__mapper__.primary_key[0].name
    pk_value = getattr(obj, pk_name)  # <-- instance value, not descriptor

    fetched = db_session.get(model_cls, pk_value)
    assert fetched is not None
